
#*The Quadratic Sieve*

二次筛法的核心思想是寻找满足`x ^ 2 = y ^ 2 (mod n)`的同余对。对这样的一对`(x, y)`，有一定概率使得`gcd(x - y, n)`是n的一个非平凡因子。

对于同余对`x ^ 2 = t`，只要找到一些x使得t的乘积能够凑成完全平方数，就能得到这样的我们需要的同余对。

我们可以将凑出的完全平方数的因子限定在一组质数基上，同时使x尽量接近sqrt(t)（使t易于分解），就能够找到一些能够被分解在质数基上的t。我们也可以用等价的方程`x ^ 2 - n = t`
当它们中的某些所含任意素因子的次数之和为偶数时，说明它们之积是完全平方数。这时问题转化为了求解异或方程组。

合法的x（称为smooth number）并不多，我们需要高效的筛选方法。

注意到当`x ^ 2 - n`能被基中的素数p整除时（p是模n的二次剩余），`p | (x + kp) ^ 2 - n`也成立。
我们只要找到在0～p-1中`x ^ 2 == n (mod p)`的两个解[Tonelli-Shanks Algorithm](http://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm)，就可以筛出能满足`p | x ^ 2 - n`的其他x。
当某一个x被足够多的p整除时，可以认为它是smooth number的概率较大，然后对其检验即可。（反之可认为几乎不可能被分解。）

#*Implementation*

本程序的实现基于GMP。
程序先判断素性，再用10 ^ 7以下的小质数试除，然后对于10^16一下的数使用[Pollard's Rho algorithm](http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm)，接下来检查这个数能否恰好开方，最后使用二次筛法。

选定素数基时，是根据`B=e^((0.5+o(1))*(sqrt(log(n))*log(log(n))))`来确定范围的。
实测中`Bound = ceil(exp(0.558 * sqrt(log(n) * log(log(n))))) + 300;`实测中效果不错。

素数基越多素数越容易分解，但是得到线性相关的向量组所需的向量也更多。同时会导致求解变慢。所以对于大数据会越来越慢。

执行筛法时，当`|log(x)-\sum_{p, p|(x^2-n)}log(p)| < max_{p}{log(p)}`时才检验x是否smooth。
对于高斯消元，使用long long压64bit。效率可以接受。

最后一步是随机生成一组解。
当素数基较大时，随机生成到非平凡因子更容易一些，但所需时间代价更大。

内存开销最大的地方是高斯消元和筛法。在使用位运算优化之后，内存消耗并不大。对于分解200bit整数最多时大约需要1G内存。

最后程序实现时在筛法和随机取解时使用了多个线程并结合了一些其他优化，最后终于在高端个人电脑和低端个人电脑上均在数小时之内成功分解了一个201bit的大整数。